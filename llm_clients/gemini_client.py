# llm_clients/gemini_client.py - Enhanced version with better error handling

import aiohttp
import asyncio
from typing import Dict, Any

class GeminiLLMClient:
    """Enhanced async client for Google Gemini API with better error handling."""
    
    def __init__(self, api_key: str, config):
        self.api_key = api_key
        self.config = config
        self.logger = config.get_logger(__name__)
        
        # Try multiple model endpoints
        self.models_to_try = [
            "gemini-1.5-flash-latest",
            "gemini-1.5-flash",
            "gemini-pro",
            "gemini-1.0-pro"
        ]
        
        self.base_url = "https://generativelanguage.googleapis.com/v1beta/models"

    async def generate(self, prompt: str) -> str:
        """Generate response using Gemini API with model fallback."""
        
        for model in self.models_to_try:
            try:
                url = f"{self.base_url}/{model}:generateContent?key={self.api_key}"
                
                payload = {
                    "contents": [{
                        "parts": [{"text": prompt}]
                    }],
                    "generationConfig": {
                        "temperature": 0.1,
                        "topK": 32,
                        "topP": 1,
                        "maxOutputTokens": 2048,
                    },
                    "safetySettings": [
                        {
                            "category": "HARM_CATEGORY_HARASSMENT",
                            "threshold": "BLOCK_MEDIUM_AND_ABOVE"
                        },
                        {
                            "category": "HARM_CATEGORY_HATE_SPEECH", 
                            "threshold": "BLOCK_MEDIUM_AND_ABOVE"
                        },
                        {
                            "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                            "threshold": "BLOCK_MEDIUM_AND_ABOVE"
                        },
                        {
                            "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
                            "threshold": "BLOCK_MEDIUM_AND_ABOVE"
                        }
                    ]
                }
                
                self.logger.info(f"Trying Gemini model: {model}")
                
                async with aiohttp.ClientSession() as session:
                    async with session.post(url, json=payload, timeout=60) as response:
                        data = await response.json()
                        
                        if response.status == 200:
                            if 'candidates' in data and len(data['candidates']) > 0:
                                content = data["candidates"][0]["content"]["parts"][0]["text"].strip()
                                self.logger.info(f"Successfully generated response using {model}")
                                return content
                            else:
                                self.logger.warning(f"No content generated by {model}")
                                continue
                        else:
                            error_msg = data.get('error', {}).get('message', 'Unknown error')
                            self.logger.warning(f"Model {model} failed: {error_msg}")
                            continue
                            
            except Exception as e:
                self.logger.warning(f"Model {model} failed with exception: {str(e)}")
                continue
        
        # If all models failed
        return "I apologize, but I'm having trouble generating a response right now. Please try again later."

    async def test_connection(self) -> Dict[str, Any]:
        """Test which models are accessible."""
        results = {}
        for model in self.models_to_try:
            try:
                url = f"{self.base_url}/{model}:generateContent?key={self.api_key}"
                payload = {
                    "contents": [{"parts": [{"text": "Hello"}]}],
                    "generationConfig": {"maxOutputTokens": 10}
                }
                
                async with aiohttp.ClientSession() as session:
                    async with session.post(url, json=payload, timeout=10) as response:
                        if response.status == 200:
                            results[model] = "Available"
                        else:
                            data = await response.json()
                            results[model] = f"Error: {data.get('error', {}).get('message', 'Unknown')}"
            except Exception as e:
                results[model] = f"Exception: {str(e)}"
        
        return results
